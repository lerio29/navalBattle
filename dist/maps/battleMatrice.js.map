{"version":3,"sources":["battleMatrice.ts"],"names":[],"mappings":"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","file":"../src/battleMatrice.js","sourcesContent":["import { Dictionary, Set }  from 'typescript-collections';\r\nimport { MatriceCase } from \"./matriceCase\"; \r\nimport { EnumStatus } from \"./enumStatus\";\r\nimport { EnumShip } from \"./enumShip\";\r\nimport {BattleUtils} from \"./battleUtils\";\r\nimport {Ship} from \"./ship\";\r\nimport {Logger} from \"./logger\";\r\n\r\n\r\n\r\n\r\n/**\r\n * Create a battle matrix \r\n * @class <p>A BattleMatrice is the war floor</p>\r\n * @author Vincent VILERIO\r\n */\r\nexport class BattleMatrice {\r\n\r\n\tprivate _logger :Logger  = new Logger();\r\n\r\n\tprivate  _matrice: Dictionary<string,MatriceCase>;\r\n\tprivate _size: number;\r\n\tprivate _ships: Set<Ship>;\r\n\tprivate _idHash: string;\r\n\r\n\r\n\t/**\r\n\t * [BattleMatrice constructor]\r\n\t * @param {number}  sizeMatrice [The size of th war floor : a square of value x value]\r\n\t * @param {boolean} silent      [Enable or disable logger]\r\n\t *\r\n\t * \r\n\t */\r\n\tconstructor(sizeMatrice? :number, silent? :boolean){\r\n\r\n\t\t\r\n\r\n\t\tif((typeof(sizeMatrice) == \"undefined\") || sizeMatrice == null ){\r\n\t\r\n\t\t\tsizeMatrice = 10; \r\n\t\t}\r\n\t\t\t\r\n\t\tlet initLoopH: number = 1;\t\r\n\r\n\t\tlet hMatrice: number = sizeMatrice;\r\n\t\tlet vMatrice: number = sizeMatrice;\r\n\t\tthis._idHash =  BattleUtils.createUniqueId();\r\n\t\tthis._size = sizeMatrice;\r\n\r\n\t\tthis._matrice = new Dictionary<string,MatriceCase>();\r\n\t\tthis._ships = new Set<Ship>();\r\n\r\n\t\tlet caseMat: MatriceCase;\r\n\r\n\r\n\t\twhile(initLoopH <= hMatrice ){\r\n\t\t\t\r\n\t\t\tlet initLoopV: number = 1;\t\r\n\t\t\twhile(initLoopV <= vMatrice){\r\n\r\n\t\t\t\tcaseMat = new MatriceCase(initLoopH, initLoopV);\r\n\t\t\t\tthis._logger.debug(\"test\", \"GenKey: \" + BattleUtils.generateKeyGridByVal(initLoopH, initLoopV));\r\n\t\t\t\t\r\n\t\t\t\tthis._matrice.setValue(BattleUtils.generateKeyGridByVal(initLoopH, initLoopV) ,caseMat);\r\n\t\t\r\n\t\t\t\tinitLoopV++ ;\r\n\t\t\t}\r\n\r\n\t\t\tinitLoopH++;\r\n\t\t    \r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\r\n\t/**\r\n\t * @description [updateMatrice method update a box values]\r\n\t * @param {MatriceCase} status [Update box datas from the key]\r\n\t */\r\n\tupdateMatrice(status :MatriceCase) :Dictionary<string,MatriceCase>{\r\n\t\t\r\n\t\t//on MAJ la case qui correspond à la cle \r\n\t\tlet tmpKey: string = BattleUtils.generateKeyGridByVal(status.hor, status.vert)\r\n\t\tthis._matrice.setValue(tmpKey,status);\r\n\t\treturn this._matrice;\r\n\t\t\r\n\t}\r\n\r\n\t/**\r\n\t * @description [addShip add a ship to the matrix]\r\n\t * @param {Ship.Ship} ship [A ship]\r\n\t */\r\n\taddShip(ship :Ship){\r\n\t\t//associer des bateau à une grille\r\n\t\tthis._ships.add(ship);\r\n\t}\r\n\r\n\t/**\r\n\t * @description [addShips add a ships set to the matrix]\r\n\t * @param {Set<Ship>} ships [ships set]\r\n\t */\r\n\taddShips(ships :Set<Ship>){\r\n\t\tfor(let ship of ships.toArray()){\r\n\t\t\tthis.addShip(ship);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [checkShipIsSet description]\r\n\t * @param  {number}   hor  [description]\r\n\t * @param  {number}   vert [description]\r\n\t * @return {EnumShip}      [description]\r\n\t */\r\n\tcheckShipIsSet(hor :number, vert :number) :EnumShip {\r\n\r\n\t\tlet result :EnumShip = undefined;\r\n\r\n\t\t//on parcourt les navires presents\r\n\t\tthis._ships.forEach(ship => {\r\n\r\n\t\t\t//on verifie les coordonnees\r\n    \t\tif(ship.shipPosition.containsKey(BattleUtils.generateKeyGridByVal(hor,vert))){\r\n    \t\t\tresult = ship.shipType;\r\n    \t\t}\r\n    \t\t\t\r\n    \t\t\r\n\t\t});\r\n\r\n\t\treturn result;    \t\t\r\n\r\n\t}\r\n\r\n\t\r\n\r\n\t/**\r\n\t * [getSize Size of matrix]\r\n\t * @return {number} [Size of matrix]\r\n\t */\r\n\tget getSize() :number{\r\n\t\treturn  this._size;\r\n\t}\r\n\r\n\t/**\r\n\t * [getShips Return all ships hooked in the matrix]\r\n\t * @return {Set<Ship>} [A ships set]\r\n\t */\r\n\tget getShips() :Set<Ship>{\r\n\t\treturn this._ships;\r\n\t}\r\n\r\n\tupdateShip(hor :number, vert :number) :boolean{\r\n\t\t\r\n\r\n\t\tthis._ships.forEach(ship => {\r\n\t\t\tif(ship.shipPosition.containsKey(BattleUtils.generateKeyGridByVal(hor,vert))){\r\n    \t\t\tship.incrementHits();\r\n    \t\t\treturn ship.checkSunk();\r\n    \t\t}\r\n\r\n\t\t});\r\n\t\t\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * [getMatrice Return all boxes in the matrix]\r\n\t * @return {Dictionary<MatriceCase>} [A boxes dictionnary]\r\n\t */\r\n\tget getMatrice() :Dictionary<string,MatriceCase>{\r\n\t\treturn this._matrice;\r\n\t}\r\n\r\n\tget getIdHash() :string {\r\n\t\treturn this._idHash;\r\n\t}\r\n}\r\n\r\n"]}